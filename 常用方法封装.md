# 常用到的方法总结

## 获取 url 中的某个参数的值

```javascript
/**
 * @method getHrefVal
 * @param {string} name (必传 查找的url中的某个参数的值)
 * @param {string} url (可选)
 * @return {string}
 */
function getHrefVal(name, url) {
  const reg = new RegExp("(^|&)" + name + "=([^&]*)(&|$)");
  let regMatch = window.location.search.substr(1).match(reg);
  if (url !== undefined) {
    let _url = url.split("?")[1];
    regMatch = _url.match(reg);
  }
  return regMatch === null ? "" : decodeURIComponent(regMatch[2]);
}
// 备注: URLSearchParams 有很大的兼容性问题
function getHrefVal(name) {
  return decodeURIComponent(
    new URLSearchParams(window.location.search).get(name)
  );
}
```

## 为 url 链接增加一个参数

```javascript
/**
 * @param {string} key (必传 要添加的参数的key)
 * @param {string} val (必传 要添加的参数的value)
 * @param {string} url (可选)
 */
function addURLParam(key, val, url = window.location.href) {
  return (url +=
    (url.indexOf("?") === -1 ? "?" : "&") +
    encodeURIComponent(key) +
    "=" +
    encodeURIComponent(val));
}
```

## 格式化数字 1234567890 --> 1,234,567,890

```javascript
/**
 * @method formatNumber
 * @param {string} str (必传 数字的字符串形式)
 * @param {string} joiner (可选 格式化的连接符)
 * @return {string}
 */
function formatNumber(str, joiner = ",") {
  const len = str.length;
  let arr = [],
    count = len;

  while (count >= 3) {
    arr.unshift(str.slice(count - 3, count));
    count -= 3;
  }
  // 数字长度如果不是3的倍数则追加上去
  len % 3 && arr.unshift(str.slice(0, len % 3));
  return arr.join(joiner);
}

function formatNumber(str, joiner = ",") {
  return str
    .split("")
    .reverse()
    .reduce((prev, next, index) => {
      return (index % 3 ? next : next + joiner) + prev;
    });
}
```

## 数据类型检测

```javascript
/**
 * @method judgeType
 * @param {*} data
 */
function judgeType(data) {
  return Object.prototype.toString
    .call(data)
    .slice(8, -1)
    .toLocaleLowerCase();
}
```

## 交换数组中两项的位置

```javascript
/**
 * @method swapArray
 * @param {Array} arr (进行操作的数组)
 * @param {number} x (位置1下标索引)
 * @param {number} y (位置2下标索引)
 * @return {Array}
 */
function swapArray(arr, x, y) {
  const swapArr = arr.concat();
  const len = arr.length;

  x < 0 && (x = len + x);
  y < 0 && (y = len + y);

  if (x < 0 || y < 0 || x > len - 1 || y > len - 1) {
    console.error("两个相互交互的位置不得大于数组长度");
    return swapArr;
  }

  if (x === y) {
    return swapArr;
  }
  // ES5 写法
  // swapArr.splice(x, 1, swapArr.splice(y, 1, swapArr[x])[0])

  // ES6 写法
  // [swapArr[x], swapArr[y]] = [swapArr[y], swapArr[x]] // 解构赋值的写法
  swapArr.splice(x, 1, ...swapArr.splice(y, 1, swapArr[x])); // 普通写法
  return swapArr;
}
```

## 格式化时间

- 将表示日期的字符串或者时间戳转换为形如 2000-09-18 15:59:08 的格式

```javascript
/**
 * @method formatDate
 * @param {string | number} date (可以被 Date.parse() 方法识别的字符串或者时间戳)
 * @return {string}
 */
function formatDate(date) {
  const date = new Date(date);
  let y = date.getFullYear();
  let m = date.getMonth() + 1;
  // m = m < 10 ? ('0'+m) : m;
  m < 10 && (m = "0" + m);
  let d = date.getDate();
  // d = d < 10 ? ('0'+d) : d;
  d < 10 && (d = "0" + d);
  let hour = date.getHours();
  hour < 10 && (hour = "0" + hour);
  let min = date.getMinutes();
  min < 10 && (min = "0" + min);
  let sec = date.getSeconds();
  sec < 10 && (sec = "0" + sec);
  return y + "-" + m + "-" + d + " " + hour + ":" + min + ":" + sec;
}
```

- 将时间戳转换为如下规则的格式：  
  1 分钟以内显示为：刚刚  
  1 小时以内显示为：N 分钟前  
  当天以内显示为：今天 N 点 N 分（如：今天 22:33）  
  昨天时间显示为：昨天 N 点 N 分（如：昨天 10:15）  
  当年以内显示为：N 月 N 日 N 点 N 分（如：02 月 03 日 09:33）  
  今年以前显示为：N 年 N 月 N 日 N 点 N 分（如：2000 年 09 月 18 日 15:59）

```javascript
/**
 * @method timestampFormat
 * @param {number} timestamp (时间戳)
 * @return {string}
 */
function timestampFormat(timestamp) {
  const zeroize = num => (String(num).length == 1 ? "0" : "") + num;

  const curTimestamp = parseInt(new Date().getTime() / 1000); //当前时间戳
  const timestampDiff = curTimestamp - timestamp; // 参数时间戳与当前时间戳相差秒数

  const curDate = new Date(curTimestamp * 1000); // 当前时间日期对象
  const tmDate = new Date(timestamp * 1000); // 参数时间戳转换成的日期对象

  const Y = tmDate.getFullYear(),
    m = tmDate.getMonth() + 1,
    d = tmDate.getDate();
  const H = tmDate.getHours(),
    i = tmDate.getMinutes(),
    s = tmDate.getSeconds();

  if (timestampDiff < 60) {
    // 一分钟以内
    return "刚刚";
  } else if (timestampDiff < 3600) {
    // 一小时前之内
    return Math.floor(timestampDiff / 60) + "分钟前";
  } else if (
    curDate.getFullYear() == Y &&
    curDate.getMonth() + 1 == m &&
    curDate.getDate() == d
  ) {
    return "今天" + zeroize(H) + ":" + zeroize(i);
  } else {
    var newDate = new Date((curTimestamp - 60 * 60 * 24) * 1000); // 24小时前的日期对象
    if (
      newDate.getFullYear() == Y &&
      newDate.getMonth() + 1 == m &&
      newDate.getDate() == d
    ) {
      return "昨天" + zeroize(H) + ":" + zeroize(i);
    } else if (curDate.getFullYear() == Y) {
      return (
        zeroize(m) + "月" + zeroize(d) + "日 " + zeroize(H) + ":" + zeroize(i)
      );
    } else {
      return (
        Y +
        "年" +
        zeroize(m) +
        "月" +
        zeroize(d) +
        "日 " +
        zeroize(H) +
        ":" +
        zeroize(i)
      );
    }
  }
}
```

- 将日期时间转换为时间差形式，形如：2 分钟前、4 小时前、5 天前

```javascript
/**
 * @method getDateDiff
 * @param {number} dateTimeStamp (时间戳)
 * @return {string}
 */
function getDateDiff(dateTimeStamp) {
  const now = new Date().getTime();
  const minute = 1000 * 60,
    hour = minute * 60,
    day = hour * 24,
    month = day * 30;
  const diffValue = now - dateTimeStamp;
  if (diffValue < 0) {
    //若日期不符则弹出窗口告之
    //alert("结束日期不能小于开始日期！");
  }
  const monthC = diffValue / month,
    weekC = diffValue / (7 * day),
    dayC = diffValue / day,
    hourC = diffValue / hour,
    minC = diffValue / minute;

  if (monthC >= 1) {
    return "发表于" + parseInt(monthC) + "个月前";
  } else if (weekC >= 1) {
    return "发表于" + parseInt(weekC) + "周前";
  } else if (dayC >= 1) {
    return "发表于" + parseInt(dayC) + "天前";
  } else if (hourC >= 1) {
    return "发表于" + parseInt(hourC) + "个小时前";
  } else if (minC >= 1) {
    return "发表于" + parseInt(minC) + "分钟前";
  } else {
    return "刚刚发表";
  }
}
```

## 筛选数据（根据一个对象中的多条件筛选出数组中符合条件的数据项）

```javascript
/**
 * @method multiFilter
 * @param {Array} originalArr (被用来筛选的原始数组)
 * @param {Object} filtersObj ()
 * @return {Array}
 */
function multiFilter(originalArr, filtersObj) {
  const filterKeys = Object.keys(filtersObj);
  return originalArr.filter(item => {
    return filterKeys.every(key => {
      if (!filtersObj[key].length) return true;
      return !!~filtersObj[key].indexOf(item[key]);
    });
  });
}
const originalArr = [
  { name: "Anne", age: 23, gender: "female" },
  { name: "Leila", age: 16, gender: "female" },
  { name: "Jay", age: 19, gender: "male" },
  { name: "Mark", age: 40, gender: "male" }
];
const filtersObj = {
  name: ["Leila", "Jay"],
  age: [19, 23]
};
// resArr: {name: "Jay", age: 19, gender: "male"}
const resArr = multiFilter(originalArr, filtersObj);
```

## 判断设备类型

```javascript
/**
 * @method os
 */
function os() {
  var ua = navigator.userAgent,
    isWindowsPhone = /(?:Windows Phone)/.test(ua),
    isSymbian = /(?:SymbianOS)/.test(ua) || isWindowsPhone,
    isAndroid = /(?:Android)/.test(ua),
    isFireFox = /(?:Firefox)/.test(ua),
    isChrome = /(?:Chrome|CriOS)/.test(ua),
    isTablet =
      /(?:iPad|PlayBook)/.test(ua) ||
      (isAndroid && !/(?:Mobile)/.test(ua)) ||
      (isFireFox && /(?:Tablet)/.test(ua)),
    isiPhone = /(?:iPhone)/.test(ua) && !isTablet,
    isPc = !isiPhone && !isAndroid && !isSymbian;
  return {
    isTablet: isTablet,
    isiPhone: isiPhone,
    isAndroid: isAndroid,
    isPc: isPc
  };
}
if (os.isAndroid || os.isiPhone) {
  window.location.href = "../phone/index.html";
} else if (os.isTablet) {
  // 屏幕宽度过小的平板(如ipad)同样展示手机端页面
  if (window.screen.availWidth < 960) {
    window.location.href = "../phone/index.html";
  }
}
```

## 封装原生 ajax 请求

```javascript
document.addEventListener("DOMContentLoaded", function() {
  const AjaxGet = new XMLHttpRequest();
  AjaxGet.onreadystatechange = function() {
    if (AjaxGet.readyState === 4) {
      if (
        (AjaxGet.status >= 200 && AjaxGet.status < 300) ||
        AjaxGet.status === 304
      ) {
        let resultData = JSON.parse(AjaxGet.responseText);
        if (resultData.code === 0) {
          console.error("参数传递错误 ");
          return;
        }
        if (resultData.resultInfo) {
          // do somethings
        }
      } else {
        console.log("request was fail: ", AjaxGet.status);
      }
    }
  };
  AjaxGet.open("get", `${window.location.origin}/api/...`, true);
  AjaxGet.send(null);
});
```

## html 字符转义

```javascript
/**
 * @method htmlEncode
 * @param {string} html
 * @return {string}
 */
function htmlEncode(html) {
  //1.首先动态创建一个容器标签元素，如DIV
  let temp = document.createElement("div");
  //2.然后将要转换的字符串设置为这个元素的innerText(ie支持)或者textContent(火狐，google支持)
  temp.textContent != undefined
    ? (temp.textContent = html)
    : (temp.innerText = html);
  //3.最后返回这个元素的innerHTML，即得到经过HTML编码转换的字符串了
  let output = temp.innerHTML;
  temp = null;
  return output;
}
```

## html 字符反转义

```javascript
/**
 * @method htmlDecode
 * @param {string} text
 * @return {string}
 */
function htmlDecode(text) {
  //1.首先动态创建一个容器标签元素，如DIV
  let temp = document.createElement("div");
  //2.然后将要转换的字符串设置为这个元素的innerHTML(ie，火狐，google都支持)
  temp.innerHTML = text;
  //3.最后返回这个元素的innerText(ie支持)或者textContent(火狐，google支持)，即得到经过HTML解码的字符串了。
  let output = temp.innerText || temp.textContent;
  temp = null;
  return output;
}
```

## 计算数组中不同值出现的次数

```javascript
/**
 * 计算数组中不同值出现的次数
 * @method arrayCount
 * @param {Array} arr
 * @return {Array}
 */
function arrayCount(arr) {
  let coachInfoNum = [];
  for (let i = 0; i < arr.length; ) {
    let count = 0;
    for (let j = i; j < arr.length; j++) {
      if (arr[i] === arr[j]) {
        count++;
      }
    }
    coachInfoNum.push({
      date: arr[i],
      count: count
    });
    i += count;
  }
  return coachInfoNum;
}
```

## 根据一个时间字符串（例如'2018-10-10'）计算年龄

```javascript
/**
 * 根据一个形如 '2018-10-10' 的字符串计算年龄
 * @method getAge
 * @param {string} dateString
 * @return {number}
 */
function getAge(dateString) {
  const today = new Date(),
    birthDate = new Date(dateString);
  let age = today.getFullYear() - birthDate.getFullYear();
  let m = today.getMonth() - birthDate.getMonth();
  if (m < 0 || (m === 0 && today.getDate() < birthDate.getDate())) {
    age--;
  }
  return age;
}
```

## 判断页面是否是在微信中打开

```javascript
/**
 * @method isWeixin
 * @return {boolen}
 */
function isWeixin() {
  return (
    window.top.navigator.userAgent.toLowerCase().indexOf("micromessenger") !==
    -1
  );
}
```

## 移动端页面跳转到相应 app 的方法

```javascript
function gotoApp() {
  var angent = window.top.navigator.userAgent.toLowerCase();
  var isAndroid =
    angent.indexOf("android") > -1 || angent.indexOf("linux") > -1;
  var isiOS = !!angent.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/i);
  // Android和ios开发者定义的一个app标示
  const appHref = "yioksnike://course";
  // 如果手机上有这个app的话就将打开并跳转到相应的app页面；因为页面跳转了，所以下面的代码将不再执行
  window.location.href = appHref;
  // 如果没有的话，
  setTimeout(function() {
    // Android前往下载页（或根据业务进行具体操作）
    isAndroid && (window.location.href = "load.html");
    // ios 前往appstore中app的相应页面
    isiOS && (window.location.href = "app_store_url");
  }, 1500);
}
```

## js 浮点运算不准确 bug 的解决办法

```javascript
// 除法
function accDiv(arg1, arg2) {
  var t1 = 0,
    t2 = 0,
    r1 = arg1.toString(),
    r2 = arg2.toString();
  try {
    t1 = r1.split(".")[1].length;
  } catch (e) {}
  try {
    t2 = r2.split(".")[1].length;
  } catch (e) {}
  r1 = Number(r1.replace(".", ""));
  r2 = Number(r2.replace(".", ""));
  return (r1 / r2) * Math.pow(10, t2 - t1);
}

//乘法
function accMul(arg1, arg2) {
  var m = 0,
    s1 = arg1.toString(),
    s2 = arg2.toString();
  try {
    m += s1.split(".")[1].length;
  } catch (e) {}
  try {
    m += s2.split(".")[1].length;
  } catch (e) {}
  return (
    (Number(s1.replace(".", "")) * Number(s2.replace(".", ""))) /
    Math.pow(10, m)
  );
}

//加法
function accAdd(arg1, arg2) {
  var r1, r2, m, c;
  try {
    r1 = arg1.toString().split(".")[1].length;
  }
  catch (e) {
    r1 = 0;
  }
  try {
    r2 = arg2.toString().split(".")[1].length;
  }
  catch (e) {
    r2 = 0;
  }
  c = Math.abs(r1 - r2);
  m = Math.pow(10, Math.max(r1, r2));
  if (c > 0) {
    var cm = Math.pow(10, c);
    if (r1 > r2) {
      arg1 = Number(arg1.toString().replace(".", ""));
      arg2 = Number(arg2.toString().replace(".", "")) * cm;
    } else {
      arg1 = Number(arg1.toString().replace(".", "")) * cm;
      arg2 = Number(arg2.toString().replace(".", ""));
    }
  } else {
    arg1 = Number(arg1.toString().replace(".", ""));
    arg2 = Number(arg2.toString().replace(".", ""));
  }
  return (arg1 + arg2) / m;
},

//减法
function accSub(arg1, arg2) {
  var r1, r2, m, n;
  try {
    r1 = arg1.toString().split(".")[1].length;
  } catch (e) {
    r1 = 0;
  }
  try {
    r2 = arg2.toString().split(".")[1].length;
  } catch (e) {
    r2 = 0;
  }
  m = Math.pow(10, Math.max(r1, r2));
  //last modify by deeka
  //动态控制精度长度
  n = r1 >= r2 ? r1 : r2;
  return ((arg2 * m - arg1 * m) / m).toFixed(n);
}
```

## 树形数组的数据结构转换

> 我把下面这种结构的数组称之为 `树形数组`

```javascript
// 此变量供下面几个 demo 共用
const data = [
  {
    uuid: "a",
    children: [
      {
        ppid: "a",
        uuid: "a-1",
        children: [
          { uuid: "a-1-1", ppid: "a-1" },
          { uuid: "a-1-2", ppid: "a-1" },
          { uuid: "a-1-3", ppid: "a-1" }
        ]
      },
      {
        ppid: "a",
        uuid: "a-2"
      }
    ]
  },
  {
    uuid: "b",
    children: [
      {
        ppid: "b",
        uuid: "b-1",
        children: [
          { uuid: "b-1-1", ppid: "b-1" },
          {
            uuid: "b-1-2",
            ppid: "b-1",
            children: [
              { uuid: "b-1-2-1", ppid: "b-1-2" },
              { uuid: "b-1-2-2", ppid: "b-1-2" }
            ]
          }
        ]
      }
    ]
  }
];
```

> 注意：下面的几个 demo 是连贯的，互相依赖的

### 扁平化树形数组

```javascript
// 扁平化树形数组
function deepFlatten(list) {
  return [].concat(
    ...list.map(type => [
      { uuid: type.uuid, ppid: type.ppid },
      ...(Array.isArray(type.children) ? deepFlatten(type.children) : [])
    ])
  );
}

const flattenType = deepFlatten(data);
console.log(flattenType);
```

### 还原树形数组

```javascript
function toTreeData(list, ppid) {
  const tree = pid =>
    list
      .filter(item => item.ppid === pid)
      .map(item => {
        const a = {
          uuid: item.uuid,
          ppid: pid
        };
        const children = tree(item.uuid);
        return children.length > 0 ? { ...a, children } : a;
      });
  return tree(ppid);
}

// 变量 flattenType 是上个 demo 中的 flattenType 变量
// 输出的数据和上面的 data 相同
console.log(toTreeData(flattenType, undefined));
```

### 寻找树形数组中某项所在的链路

```javascript
function idList(list, uuid) {
  const result = [];
  function a(id) {
    for (let i = 0; i < list.length; i++) {
      const item = list[i];
      if (item.uuid === id) {
        result.unshift(item.uuid);
        a(item.ppid);
        break;
      }
    }
  }
  a(uuid);
  return result;
}
// 输出： ["b", "b-1", "b-1-2", "b-1-2-1"]
console.log(idList(flattenType, "b-1-2-1"));
```
